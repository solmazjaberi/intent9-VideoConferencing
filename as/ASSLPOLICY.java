package generatedbyassl.as;

import java.util.Hashtable;
import java.util.Enumeration;

/**
 * Generated by ASSL Framework
 * 
 * This is the superclass for all ASSL self-management policies.
 */
public class ASSLPOLICY
{

	/**
	 * Generated by ASSL Framework
	 * 
	 * Holds pairs 'fluent name'-'fluent reference' of all the policy fluents.
	 */
	protected Hashtable<String, ASSLFLUENT> vFluents = new Hashtable<String, ASSLFLUENT>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines whether the policy is ON/OFF.
	 */
	protected boolean SWITCH = true;
	/**
	 * Generated by ASSL Framework
	 * 
	 * This data member sets the policy priority.
	 */
	protected int PRIORITY = 1;
	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines whether the ASSL policy must stop.
	 */
	protected boolean bStopPolicy = false;
	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines whether the policy has been started.
	 */
	private boolean bStarted = false;
	/**
	 * Generated by ASSL Framework
	 * 
	 * This is the thread group of all threads that run actions specified in the policy MAPPING clauses.
	 */
	protected ThreadGroup thrdgrMappings = new ThreadGroup("policy_mappings");;

	/**
	 * Generated by ASSL Framework
	 * 
	 * Returns a reference to a fluent specified by name.
	 */
	public ASSLFLUENT getFluent ( String psFluentName )
	{
		return vFluents.get(psFluentName);
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Returns true if the policy has been switched on.
	 */
	public boolean isSwitchedOn (  )
	{
		return SWITCH;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Switches ON/OFF the policy.
	 */
	public synchronized void switchON ( boolean bSwtichON )
	{
		if ( bSwtichON != SWITCH ) 
		{
			Enumeration<ASSLFLUENT> eFluents = vFluents.elements();
			ASSLFLUENT currFluent = null;
			while ( eFluents.hasMoreElements() ) 
			{
				currFluent = eFluents.nextElement();
				currFluent.pause(!bSwtichON);
			}
			SWITCH = bSwtichON;
		}
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method stops the ASSL policy.
	 */
	public void stopPolicy (  )
	{
		bStopPolicy=true;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Returns true if the policy has been started.
	 */
	public synchronized boolean isStarted (  )
	{
		return bStarted;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method determines whether the policy is satisfied, i.e., the policy is not in neither one of its fluents.
	 */
	public synchronized boolean isPolicySatisfied (  )
	{
		boolean bPolicySatisfied = true;
		Enumeration<ASSLFLUENT> eFluents = vFluents.elements();
		ASSLFLUENT currFluent = null;
		while ( eFluents.hasMoreElements() ) 
		{
			currFluent = eFluents.nextElement();
			//**** A policy is not satisfied if there is at least one initiated fluent for that policy.
			if ( currFluent.isFluentInitiated() ) 
			{
				bPolicySatisfied = false;
				break;
			}
		}
		return bPolicySatisfied;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Checks whether the thread that runs a specific policy MAPPING is running.
	 */
	protected synchronized boolean isMappingRunning ( String psConditions )
	{
		boolean bResult = false;
		Thread ta[] = new Thread[thrdgrMappings.activeCount()];
		int numThread = thrdgrMappings.enumerate(ta);
		for ( int i=0; i<numThread; i++ ) 
		{
			if ( ta[i].getName().equalsIgnoreCase(psConditions) ) 
			{
				bResult = true;
				break;
			}
		}
		return bResult;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * For each specified MAPPING, checks if the MAPPING conditions are fulfilled and if so spawn a thread to perform the MAPPING actions.
	 */
	public synchronized void doAllMappings (  )
	{
		//**** Override this method in descendant classes.
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Overrides Thread's start() method - starts the fluents first and then the policy.
	 */
	public void start (  )
	{
		String sMsg = "POLICY '" + this.getClass().getName() + "': started";
		Enumeration<ASSLFLUENT> eFluents = vFluents.elements();
		ASSLFLUENT currFluent = null;
		//**** starts the fluents
		while ( eFluents.hasMoreElements() ) 
		{
			currFluent = eFluents.nextElement();
			currFluent.start();
			while ( !currFluent.isStarted() ) 
			{
			}
		}
		System.out.println( sMsg );
		bStarted = true;
	}

}