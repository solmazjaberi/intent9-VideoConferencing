package generatedbyassl.as;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Date;
import java.util.Calendar;
import java.util.Locale;

/**
 * Generated by ASSL Framework
 * 
 * This is the superclass for all ASSL events.
 */
public class ASSLEVENT
	extends Thread
	implements  ASSLEVENTCATCHER, ASSLMESSAGECATCHER
{

	/**
	 * Generated by ASSL Framework
	 * 
	 * Event duration units.
	 */
	public static String sEventDrtnUnts[] = { "YEAR", "MONTH", "DAY", "HOUR", "MIN", "SEC", "MSEC" };
	/**
	 * Generated by ASSL Framework
	 * 
	 * Event duration unit.
	 */
	protected String sEventDrtnUnt = sEventDrtnUnts[6];
	/**
	 * Generated by ASSL Framework
	 * 
	 * This is the event life-span (duration) - initially set to 1000 MSEC (milliseconds).
	 */
	public Float DURATION = new Float(1000);
	/**
	 * Generated by ASSL Framework
	 * 
	 * Event 'prompt' time.
	 */
	protected Date dtPromptTime = AUTONOMICNETWORK.getDateTime("01.01.1900");
	/**
	 * Generated by ASSL Framework
	 * 
	 * Event 'start' time.
	 */
	protected Date dtStartTime = AUTONOMICNETWORK.getDateTime("01.01.1900");
	/**
	 * Generated by ASSL Framework
	 * 
	 * Vector for the the event periods.
	 */
	protected Vector<Float> vPeriods = new Vector<Float>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Vector for the the event period units.
	 */
	protected Vector<String> vPeriodUnits = new Vector<String>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Vector for the the last elapsed time of the event periods.
	 */
	protected Vector<Date> vPeriodTimes = new Vector<Date>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Messages that have been received since the last check of the event conditions.
	 */
	protected Vector<ASSLMESSAGE> vReceivedMessages = new Vector<ASSLMESSAGE>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Messages that have been sent since the last check of the event conditions.
	 */
	protected Vector<ASSLMESSAGE> vSentMessages = new Vector<ASSLMESSAGE>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Events that have occurred since the last check of the event conditions.
	 */
	protected Vector<ASSLEVENT> vOccurredEvents = new Vector<ASSLEVENT>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Holds  SLO that this event declares in its DEGRADED and NORMALIZED activation clauses.
	 */
	protected Vector<ASSLSLO> vSLO = new Vector<ASSLSLO>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Holds the previous states of SLO that this event declares in its DEGRADED and NORMALIZED activation clauses.
	 */
	protected Vector<Boolean> vPreviousSLOState = new Vector<Boolean>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * This vector holds all the event-catcher classes listening to this event.
	 */
	private Vector<ASSLEVENTCATCHER> vEventCatchers = new Vector<ASSLEVENTCATCHER>();
	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines whether the ASSL event must stop.
	 */
	protected boolean bStopEvent = false;
	/**
	 * Generated by ASSL Framework
	 * 
	 * This data member determines whether the event must by triggered.
	 */
	protected boolean bTriggerEvent = false;
	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines whether the event has been started.
	 */
	private boolean bStarted = false;

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method notifies the ASSL event-catcher class that a specific event has been prompted.
	 */
	public synchronized void notifyForEvent ( ASSLEVENT poEvent )
	{
		vOccurredEvents.add(poEvent);
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Notifies the ASSL message-catcher class that a specific message has been received.
	 */
	public void notifyForReceivedMessage ( ASSLMESSAGE poMessage )
	{
		vReceivedMessages.add( poMessage );
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Notifies the ASSL message-catcher class that a specific message has been sent.
	 */
	public void notifyForSentMessage ( ASSLMESSAGE poMessage )
	{
		vSentMessages.add( poMessage );
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Returns true if the event has been started.
	 */
	public synchronized boolean isStarted (  )
	{
		return bStarted;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Initialises the event after the system has been started.
	 */
	public synchronized void postStartInit (  )
	{
		//**** Override this method in the child class when have to initialise the object after the system has been started. 
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Checks whether an event has occurred since the last check of the event conditions.
	 */
	protected synchronized boolean isEventOccurred ( ASSLEVENT poEvent )
	{
		boolean bResult = false;
		for ( int i=0; i<vOccurredEvents.size(); i++ ) 
		{
			if ( vOccurredEvents.elementAt(i).equals(poEvent) ) 
			{
				bResult = true;
				break;
			}
		}
		return bResult;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Checks whether a message has been received since the last check of the event conditions.
	 */
	protected synchronized boolean isMessageReceived ( ASSLMESSAGE poMessage )
	{
		boolean bResult = false;
		for ( int i=0; i<vReceivedMessages.size(); i++ ) 
		{
			if ( vReceivedMessages.elementAt(i).equals(poMessage) ) 
			{
				bResult = true;
				break;
			}
		}
		return bResult;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Checks whether a message has been sent since the last check of the event conditions.
	 */
	protected synchronized boolean isMessageSent ( ASSLMESSAGE poMessage )
	{
		boolean bResult = false;
		for ( int i=0; i<vSentMessages.size(); i++ ) 
		{
			if ( vSentMessages.elementAt(i).equals(poMessage) ) 
			{
				bResult = true;
				break;
			}
		}
		return bResult;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Produces a new date from another date by adding a period to the latter.
	 */
	protected Calendar addPeriodToDate ( Date pdtBaseDate, int piPeriod, String psUnit )
	{
		Calendar oCalendar = Calendar.getInstance( Locale.US);
		oCalendar.setTime( pdtBaseDate );
		//**** the unit is YEAR
		if ( psUnit.equals( sEventDrtnUnts[0] ) ) 
		{
			oCalendar.add(Calendar.YEAR, piPeriod);
		}
		//**** the unit is MONTH
		if ( psUnit.equals( sEventDrtnUnts[1] ) ) 
		{
			oCalendar.add(Calendar.MONTH, piPeriod);
		}
		//**** the unit is DAY
		if ( psUnit.equals( sEventDrtnUnts[2] ) ) 
		{
			oCalendar.add(Calendar.DAY_OF_YEAR, piPeriod);
		}
		//**** the unit is HOUR
		if ( psUnit.equals( sEventDrtnUnts[3] ) ) 
		{
			oCalendar.add(Calendar.HOUR, piPeriod);
		}
		//**** the unit is MIN
		if ( psUnit.equals( sEventDrtnUnts[4] ) ) 
		{
			oCalendar.add(Calendar.MINUTE, piPeriod);
		}
		//**** the unit is SEC
		if ( psUnit.equals( sEventDrtnUnts[5] ) ) 
		{
			oCalendar.add(Calendar.SECOND, piPeriod);
		}
		//**** the unit is MSEC
		if ( psUnit.equals( sEventDrtnUnts[6] ) ) 
		{
			oCalendar.add(Calendar.MILLISECOND, piPeriod);
		}
		//**********************************************************
		return oCalendar;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines if at least one event period has elapsed.
	 */
	protected boolean isPeriodElapsed (  )
	{
		boolean bResult = false;
		for ( int i=0; i<vPeriods.size(); i++ ) 
		{
			Date oNow = new Date ();
			Calendar oPeriodDate = addPeriodToDate( vPeriodTimes.elementAt(i), vPeriods.elementAt(i).intValue(), vPeriodUnits.elementAt(i));
			if ( oNow.after(oPeriodDate.getTime()) ) 
			{
				vPeriodTimes.setElementAt(oPeriodDate.getTime(), i);
				bResult = true;
			}
		}
		return bResult;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines if the event is still prompted.
	 */
	public synchronized boolean isPrompted (  )
	{
		Date currDate = new Date();
		Calendar oCalendar = addPeriodToDate( dtPromptTime, DURATION.intValue(), sEventDrtnUnt );
		if ( oCalendar.after(currDate) ) 
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Determines if specific SLO have changed their state.
	 */
	protected boolean isSLOChangedState ( int piSLOIndex )
	{
		boolean bResult = false;
		Boolean bNewSLOState = vSLO.elementAt(piSLOIndex).isSatisfied();
		if ( bNewSLOState != vPreviousSLOState.elementAt(piSLOIndex) ) 
		{
			vPreviousSLOState.setElementAt(bNewSLOState, piSLOIndex);
			bResult = true;
		}
		return bResult;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method adds a new event-catcher class to the list of event catchers listening to that event.
	 */
	public synchronized void addEventCatcher ( ASSLEVENTCATCHER pEventCatcher )
	{
		vEventCatchers.add(pEventCatcher);
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method stops the ASSL event.
	 */
	public void stopEvent (  )
	{
		bStopEvent=true;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Provides conditions to be fulfilled before processing the event.
	 */
	public boolean GUARDS (  )
	{
		return true;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * Triggers the event via an external call.
	 */
	public synchronized void triggerEvent (  )
	{
		if ( GUARDS() ) 
		{
			bTriggerEvent=true;
			String sMsg = "EVENT '" + this.getClass().getName() + "': has occurred";
			System.out.println( sMsg );
		}
		else
		{
			bTriggerEvent=false;
			String sMsg = "EVENT '" + this.getClass().getName() + "': has been prevented by GUARDS";
			System.out.println( sMsg );
		}
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method checks the event's prompting conditions and if satisfied triggers the event.
	 */
	protected void checkEventConditions (  )
	{
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method notifies all the event-catcher classes that the event has been prompted.
	 */
	private synchronized void notifyEventCatchers (  )
	{
		Enumeration<ASSLEVENTCATCHER> eEventCatchers = vEventCatchers.elements();
		ASSLEVENTCATCHER currEventCatcher = null;
		while ( eEventCatchers.hasMoreElements() ) 
		{
			currEventCatcher = eEventCatchers.nextElement();
			currEventCatcher.notifyForEvent(this);
		}
		try
		{
			Thread.sleep( DURATION.longValue() );
		}
		catch ( InterruptedException ex ) 
		{
			System.err.println( ex.getMessage() );
		}
		bTriggerEvent=false;
	}

	/**
	 * Generated by ASSL Framework
	 * 
	 * This method runs the event thread until the stop conditions are not fulfilled.
	 */
	public void run (  )
	{
		//**** sets the 'start' time
		dtStartTime = new Date();
		//*********************************************************
		String sMsg = "EVENT '" + this.getClass().getName() + "': started";
		System.out.println( sMsg );
		bStarted = true;
		//**** runs the event
		while ( !bStopEvent ) 
		{
			try
			{
				Thread.sleep(100);
			}
			catch ( InterruptedException ex ) 
			{
				System.err.println( ex.getMessage() );
			}
			checkEventConditions();
			if ( bTriggerEvent ) 
			{
				notifyEventCatchers();
			}
		}
	}

}